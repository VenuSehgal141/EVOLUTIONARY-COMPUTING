class Bunch:
    def __init__(self, radii):
        self.circles = [Circle(r) for r in radii]
        self.radii = radii
    
    def reset(self):
        """Reset all circles to unplaced state"""
        for circle in self.circles:
            circle.x = 0
            circle.y = 0
            circle.placed = False
    
    def get_containing_radius(self):
        """Get the maximum containing radius across all circles"""
        if not self.circles:
            return 0
        return max(c.containing_radius() for c in self.circles if c.placed)
    
    def find_open_points(self, new_circle):
        """
        Find all 'open points' where new_circle can be placed.
        An open point is a position where the circle is tangent to one or two existing circles.
        """
        open_points = []
        placed = [c for c in self.circles if c.placed]
        
        if len(placed) == 0:
            # First circle goes at origin
            return [(0, 0, 0)]
        
        if len(placed) == 1:
            # Second circle: place tangent to first, try multiple angles
            c1 = placed[0]
            distance = c1.radius + new_circle.radius
            for angle in np.linspace(0, 2*np.pi, 36, endpoint=False):
                x = c1.x + distance * np.cos(angle)
                y = c1.y + distance * np.sin(angle)
                dist_from_origin = np.sqrt(x**2 + y**2)
                open_points.append((x, y, dist_from_origin))
            return open_points
        
        # For subsequent circles: find positions tangent to pairs of existing circles
        for i in range(len(placed)):
            for j in range(i+1, len(placed)):
                c1 = placed[i]
                c2 = placed[j]
                
                # Find positions where new circle is tangent to both c1 and c2
                positions = self.find_tangent_positions(c1, c2, new_circle)
                for x, y in positions:
                    # Check if this position overlaps with any other placed circle
                    temp_circle = Circle(new_circle.radius)
                    temp_circle.set_position(x, y)
                    
                    valid = True
                    for other in placed:
                        if other != c1 and other != c2:
                            if temp_circle.overlaps(other):
                                valid = False
                                break
                    
                    if valid:
                        dist_from_origin = np.sqrt(x**2 + y**2)
                        open_points.append((x, y, dist_from_origin))
        
        return open_points
    
    def find_tangent_positions(self, c1, c2, new_circle):
    
        r1 = c1.radius + new_circle.radius
        r2 = c2.radius + new_circle.radius
        
        # Distance between c1 and c2
        d = c1.distance_to(c2)
        
        # Check if circles can be tangent (triangle inequality)
        if d > r1 + r2 or d < abs(r1 - r2) or d == 0:
            return []
        
        # Use formula for intersection of two circles
        a = (r1**2 - r2**2 + d**2) / (2*d)
        h = np.sqrt(max(0, r1**2 - a**2))
        
        # Point on line between c1 and c2
        px = c1.x + a * (c2.x - c1.x) / d
        py = c1.y + a * (c2.y - c1.y) / d
        
        # Two intersection points (perpendicular to line c1-c2)
        positions = []
        if h > 0.01:  # Two distinct points
            positions.append((
                px + h * (c2.y - c1.y) / d,
                py - h * (c2.x - c1.x) / d
            ))
            positions.append((
                px - h * (c2.y - c1.y) / d,
                py + h * (c2.x - c1.x) / d
            ))
        else:  # One point (circles just touch)
            positions.append((px, py))
        
        return positions
    
    def ordered_place(self):
        """Place circles in order, each at the closest valid position to origin"""
        self.reset()
        for circle in self.circles:
            open_points = self.find_open_points(circle)
            
            if open_points:
                # Find position closest to origin
                best_position = min(open_points, key=lambda p: p[2])
                circle.set_position(best_position[0], best_position[1])
    
    def random_place(self):
        """
        Implement random placement algorithm

        - Shuffle the order of circles randomly
        - Place each circle (in shuffled order) at the closest valid position to the origin
        """
        # 1. Reset all circles
        self.reset()

        # 2. Create a shuffled copy of the circle objects
        shuffled = self.circles[:]
        random.shuffle(shuffled)

        # 3. Place each circle in the shuffled order at the open point closest to origin
        for circle in shuffled:
            open_points = self.find_open_points(circle)
            if open_points:
                best_position = min(open_points, key=lambda p: p[2])
                circle.set_position(best_position[0], best_position[1])
            else:
                # Fallback: if no open points found (should be rare), place at origin
                circle.set_position(0, 0)
    
    def greedy_place(self):
       
        # 1. Reset placement
        self.reset()

        # 2. Sort circles by descending radius (largest first)
        sorted_circles = sorted(self.circles, key=lambda c: c.radius, reverse=True)

        # 3. Place each circle at the open point closest to origin
        for circle in sorted_circles:
            open_points = self.find_open_points(circle)
            if open_points:
                best_position = min(open_points, key=lambda p: p[2])
                circle.set_position(best_position[0], best_position[1])
            else:
                # Fallback: place at origin if no valid open point found
                circle.set_position(0, 0)
    
    def draw(self, title="Circle Placement", show_open_points=False):
        """Visualize the circle placement"""
        fig, ax = plt.subplots(figsize=(10, 10))
        
        # Draw containing circle
        containing_radius = self.get_containing_radius()
        containing_circle = PltCircle((0, 0), containing_radius, 
                                     fill=False, edgecolor='#F4BA02', 
                                     linewidth=2, linestyle='--', label='Containing radius')
        ax.add_patch(containing_circle)
        
        # Show open points if requested (for demonstration)
        if show_open_points and len([c for c in self.circles if c.placed]) < len(self.circles):
            next_circle = [c for c in self.circles if not c.placed][0]
            open_points = self.find_open_points(next_circle)
            if open_points:
                xs, ys = zip(*[(p[0], p[1]) for p in open_points])
                ax.scatter(xs, ys, c='lime', s=30, alpha=0.5, zorder=5, label='Open points')
        
        # Draw each placed circle
        for circle in self.circles:
            if circle.placed:
                circle_patch = PltCircle((circle.x, circle.y), circle.radius,
                                        fill=False, edgecolor='#99D9DD', linewidth=2)
                ax.add_patch(circle_patch)
                
                # Mark center
                ax.plot(circle.x, circle.y, 'o', color='#99D9DD', markersize=6)
                
                # Show radius value
                ax.text(circle.x, circle.y, f'{int(circle.radius)}', 
                       ha='center', va='center', color='#F7F8F9', fontsize=9)
        
        # Mark origin
        ax.plot(0, 0, 'x', color='#F4BA02', markersize=12, markeredgewidth=3, label='Origin')
        
        # Set equal aspect ratio and limits
        ax.set_aspect('equal')
        margin = containing_radius * 0.15
        ax.set_xlim(-containing_radius - margin, containing_radius + margin)
        ax.set_ylim(-containing_radius - margin, containing_radius + margin)
        
        ax.grid(True, alpha=0.3, color='#F7F8F9')
        ax.set_facecolor('#01364C')
        fig.patch.set_facecolor('#01364C')
        ax.tick_params(colors='#F7F8F9')
        ax.spines['bottom'].set_color('#F7F8F9')
        ax.spines['top'].set_color('#F7F8F9')
        ax.spines['left'].set_color('#F7F8F9')
        ax.spines['right'].set_color('#F7F8F9')
        
        ax.set_title(f"{title}\nContaining Radius: {containing_radius:.2f}", 
                    color='#F7F8F9', fontsize=14, pad=20, weight='bold')
        ax.legend(loc='upper right', facecolor='#01364C', edgecolor='#F7F8F9', 
                 labelcolor='#F7F8F9', framealpha=0.9)
        plt.show()